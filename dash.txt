Project Path: Projet_Dash

Source Tree:

```
Projet_Dash
├── app.py
├── data
│   ├── annotations.json
│   ├── cars
│   │   ├── 208.jpg
│   │   ├── car425.jpg
│   │   ├── car426.jpg
│   │   ├── car427.jpg
│   │   ├── car428.jpg
│   │   ├── car429.jpg
│   │   ├── car430.jpg
│   │   ├── car431.jpg
│   │   ├── car432.jpg
│   │   ├── car433.jpg
│   │   ├── car434.jpg
│   │   ├── car435.jpg
│   │   ├── car436.jpg
│   │   ├── flashmcqueen.jpeg
│   │   ├── mazdacx3.jpg
│   │   └── porsche 911-gt3rs.jpeg
│   └── users.json
├── pages
│   ├── accueil.py
│   ├── annotation.py
│   ├── annoter.py
│   ├── login.py
│   ├── stats.py
│   ├── verify.py
│   └── __pycache__
│       ├── accueil.cpython-311.pyc
│       ├── accueil.cpython-312.pyc
│       ├── annotation.cpython-311.pyc
│       ├── annotation.cpython-312.pyc
│       ├── annoter.cpython-311.pyc
│       ├── annoter.cpython-312.pyc
│       ├── contexte.cpython-312.pyc
│       ├── login.cpython-311.pyc
│       ├── login.cpython-312.pyc
│       ├── stats.cpython-311.pyc
│       ├── stats.cpython-312.pyc
│       ├── truc.cpython-312.pyc
│       └── verify.cpython-311.pyc
└── requirements.txt

```

`\\?\J:\BUT SD\S5\Projet_Dash\app.py`:

```py
import dash
from dash import dcc, html, callback, Input, Output
import dash_bootstrap_components as dbc

app = dash.Dash(__name__, use_pages=True, external_stylesheets=[
    dbc.themes.BOOTSTRAP, 
    "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css",
    "https://fonts.googleapis.com/css2?family=Roboto&display=swap",
    ])

app.layout = html.Div([
    dcc.Location(id='url', refresh=True),
    dbc.NavbarSimple(
        children=[
            dbc.NavLink('Accueil', href='/accueil'),
            dbc.NavLink('Interface d\'annotation', href='/annoter'),
            dbc.NavLink('Liste des annotations', href='/annotation'),
            dbc.NavLink('Statistiques', href='/stats'),
            html.Span(id='user_status', className='text-light align-self-center', style={'font-size': '0.9rem', 'marginLeft': '100px', 'marginRight':'20px'}),
            dbc.Button('Déconnexion', color='danger', outline=True, className='text-light align-self-center', style={'font-size': '0.8rem'}, id='logout_button', n_clicks=0),
        ],
        brand="Projet d'Annotation M2VT",
        color="#333333",
        dark=True,
        id='navbar',
    ),
    dash.page_container,
    dcc.Store(id='user_name_store', storage_type='local')  # Pour stocker le nom d'utilisateur en cours sur la session
])

@callback(
    Output('user_status', 'children', allow_duplicate=True),
    Input('user_name_store', 'data'),
    prevent_initial_call='True'
)
def afficher_message_loggé(user_name):
    if user_name:
        return f"Vous êtes loggé en tant que {user_name}."
    return "Vous n'êtes pas loggé."

@callback(
    Output('navbar', 'style'),
    Input('url', 'pathname'),
)

def toggle_navbar(pathname):
    # On masque la navbar sur la page de login
    if pathname == '/':
        return {'display': 'none'}
    return {'display': 'block'}

@callback(
    Output('url', 'href', allow_duplicate=True),
    Input('logout_button', 'n_clicks'),
    prevent_initial_call=True
)

def handle_logout(n_clicks):
    if n_clicks > 0:
        return '/'  # Redirection vers la page de connexion
    return dash.no_update

if __name__ == '__main__':
    app.run(debug=True)
```

`\\?\J:\BUT SD\S5\Projet_Dash\data\annotations.json`:

```json
[
  {
    "id": 1,
    "image_name": "car428.jpg",
    "annotateur": "Vadim",
    "date": "2024-10-06",
    "reviewer": "",
    "review_date": "",
    "annotations": [
      {
        "editable": true,
        "label": {
          "text": "",
          "texttemplate": ""
        },
        "xref": "x",
        "yref": "y",
        "layer": "above",
        "opacity": 0.3,
        "line": {
          "color": "black",
          "width": 2,
          "dash": "solid"
        },
        "fillcolor": "cyan",
        "fillrule": "evenodd",
        "type": "rect",
        "x0": 11.713121771043342,
        "y0": 150.8625754079511,
        "x1": 206.4937669323336,
        "y1": 252.1141883111769
      }
    ]
  },
  {
    "id": 2,
    "image_name": "car436.jpg",
    "annotateur": "Manon",
    "date": "2024-10-06",
    "reviewer": "Vadim",
    "review_date": "2024-10-06",
    "annotations": [
      {
        "editable": true,
        "label": {
          "text": "",
          "texttemplate": ""
        },
        "xref": "x",
        "yref": "y",
        "layer": "above",
        "opacity": 0.3,
        "line": {
          "color": "black",
          "width": 2,
          "dash": "solid"
        },
        "fillcolor": "cyan",
        "fillrule": "evenodd",
        "type": "rect",
        "x0": 55.45099113218247,
        "y0": 125.38967157179312,
        "x1": 426.22195887411806,
        "y1": 284.42838124921246
      }
    ]
  },
  {
    "id": 3,
    "image_name": "flashmcqueen.jpeg",
    "annotateur": "Manon",
    "date": "2024-10-06",
    "reviewer": "Vadim",
    "review_date": "2024-10-06",
    "annotations": [
      {
        "editable": true,
        "label": {
          "text": "",
          "texttemplate": ""
        },
        "xref": "x",
        "yref": "y",
        "layer": "above",
        "opacity": 0.3,
        "line": {
          "color": "black",
          "width": 2,
          "dash": "solid"
        },
        "fillcolor": "cyan",
        "fillrule": "evenodd",
        "type": "rect",
        "x0": 30.281905241935487,
        "y0": 115.44321446572582,
        "x1": 994.6173891129033,
        "y1": 513.0690209173388
      }
    ]
  },
  {
    "id": 4,
    "image_name": "208.jpg",
    "annotateur": "Manon",
    "date": "2024-10-06",
    "reviewer": "Ma\u00ebl",
    "review_date": "2024-10-06",
    "annotations": [
      {
        "editable": true,
        "label": {
          "text": "",
          "texttemplate": ""
        },
        "xref": "x",
        "yref": "y",
        "layer": "above",
        "opacity": 0.3,
        "line": {
          "color": "black",
          "width": 2,
          "dash": "solid"
        },
        "fillcolor": "cyan",
        "fillrule": "evenodd",
        "type": "rect",
        "x0": 198.37207799111647,
        "y0": 149.7716024091167,
        "x1": 714.1785296040199,
        "y1": 466.1328927316974
      }
    ]
  },
  {
    "id": 5,
    "image_name": "porsche 911-gt3rs.jpeg",
    "annotateur": "Manon",
    "date": "2024-10-06",
    "reviewer": "Ma\u00ebl",
    "review_date": "2024-10-06",
    "annotations": [
      {
        "editable": true,
        "label": {
          "text": "",
          "texttemplate": ""
        },
        "xref": "x",
        "yref": "y",
        "layer": "above",
        "opacity": 0.3,
        "line": {
          "color": "black",
          "width": 2,
          "dash": "solid"
        },
        "fillcolor": "cyan",
        "fillrule": "evenodd",
        "type": "rect",
        "x0": 4.848605642011087,
        "y0": 39.31418831117691,
        "x1": 447.60989596459154,
        "y1": 234.09483347246723
      }
    ]
  }
]
```

`\\?\J:\BUT SD\S5\Projet_Dash\data\users.json`:

```json
[
    {
        "id": 1,
        "name": "Thibault"
    },
    {
        "id": 2,
        "name": "Vadim"
    },
    {
        "id": 3,
        "name": "Manon"
    },
    {
        "id": 4,
        "name": "Ma\u00ebl"
    }
]
```

`\\?\J:\BUT SD\S5\Projet_Dash\pages\accueil.py`:

```py
import dash
from dash import html, callback, Output, Input, State, dcc
import dash_bootstrap_components as dbc

dash.register_page(__name__)

layout = html.Div([
    dcc.Store(id='user_name_store', storage_type='local'), # Pour stocker le nom d'utilisateur en cours sur la session
    html.H1("C'est la page de contexte"),
    html.Div("C'est la page de contexte"),
    html.Div(id='welcome_message')  # Dans ton layout
])

# Callback pour afficher le message de bienvenue avec le nom d'utilisateur
@dash.callback(
    Output('welcome_message', 'children'),
    Input('user_name_store', 'data')
)
def afficher_nom_user(user_name):
    if user_name:
        return html.H4(f"Bienvenue {user_name} !", className="text-center")
    else:
        return html.H4("Bienvenue, veuillez vous connecter.", className="text-center")
```

`\\?\J:\BUT SD\S5\Projet_Dash\pages\annotation.py`:

```py
import dash
from dash import html, dcc, dash_table, Input, Output, State
import json
import os
from datetime import datetime

dash.register_page(__name__)

annotations_file = './data/annotations.json'

def load_annotations():
    """Load annotations from the JSON file."""
    if os.path.exists(annotations_file):
        with open(annotations_file, 'r') as f:
            return json.load(f)
    return []

def prepare_table_data():
    """Prepare data for the DataTable from annotations."""
    annotations = load_annotations()
    table_data = []
    
    for annotation in annotations:
        table_data.append({
            'Image Name': annotation.get('image_name', 'N/A'),
            'Date': annotation.get('date', 'N/A'),
            'Annotateur': annotation.get('annotateur', 'Anonyme'),
            'Reviewer': annotation.get('reviewer', 'N/A'),
            'Review Date': annotation.get('review_date', 'N/A'),
            'id': annotation.get('id')
        })
    
    # Sorting the data
    table_data.sort(key=lambda x: (x['Reviewer'] == 'N/A', x['Reviewer'], datetime.strptime(x['Date'], '%Y-%m-%d') if x['Date'] != 'N/A' else datetime.min))
    
    return table_data

columns = [
    {'name': 'Image Name', 'id': 'Image Name'},
    {'name': 'Date', 'id': 'Date'},
    {'name': 'Annotateur', 'id': 'Annotateur'},
    {'name': 'Reviewer', 'id': 'Reviewer'},
    {'name': 'Review Date', 'id': 'Review Date'},
    {'name': 'Verifier', 'id': 'Verifier', 'presentation': 'markdown'}
]

# Layout for the annotation page
layout = html.Div([
    html.H1("Liste des Annotations"),
    html.Div("Voici la liste des annotations effectuées :"),
    
    dash_table.DataTable(
        id='annotation-table',
        columns=columns,
        data=[
            {**row, 'Verifier': f'[Verifier](/verify?id={row["id"]})'}
            for row in prepare_table_data()
        ],
        style_table={'width': '80%', 'margin': 'auto'},
        style_header={'backgroundColor': 'rgb(230, 230, 230)', 'fontWeight': 'bold'},
        style_cell={'textAlign': 'left'},
        page_size=10,
    )
])

# Callback to update the table dynamically
@dash.callback(
    Output('annotation-table', 'data'),
    Input('annotation-table', 'data')  # Dummy input to trigger update on any change
)
def update_table(_):
    """Callback to update the DataTable with the latest annotation data."""
    return [
        {**row, 'Verifier': f'[Verifier](/verify?id={row["id"]})'}
        for row in prepare_table_data()
    ]

```

`\\?\J:\BUT SD\S5\Projet_Dash\pages\annoter.py`:

```py
import dash
from dash import dcc, html, Input, Output, callback, State
from skimage import io
import plotly_express as px
import os
import json
import random
import base64
import dash_bootstrap_components as dbc
from datetime import datetime

# Define paths for images and JSON files
dossier_img = './data/cars/'
users_file = './data/users.json'
annotations_file = './data/annotations.json'

# Function to retrieve a random image
def recup_img_aleatoire():
    files = os.listdir(dossier_img)
    images = [file for file in files if file.endswith(('png', 'jpg', 'jpeg'))]
    if images:
        random_image = random.choice(images)
        return os.path.join(dossier_img, random_image)
    return None

# Function to load an image and return it with its filename
def charger_image():
    chemin_image = recup_img_aleatoire()
    if chemin_image:
        img = io.imread(chemin_image)
        return img, os.path.basename(chemin_image)  # Return both image and filename
    return None, None  # Return None for both if no image is found

# Function to save uploaded image
def save_img(content, filename):
    data = content.split(",")[1]
    img_data = base64.b64decode(data)
    file_unique = f"{filename}"
    filepath = os.path.join(dossier_img, file_unique)
    with open(filepath, 'wb') as f:
        f.write(img_data)
    return filepath

# Register the Dash app page
dash.register_page(__name__)

# Load initial image and filename
img, filename = charger_image()

if img is not None:
    fig = px.imshow(img)
    fig.update_layout(
        dragmode="drawrect",
        newshape=dict(fillcolor="cyan", opacity=0.3, line=dict(color="black", width=2)),
    )
else:
    fig = None

# Layout of the Dash app
layout = html.Div(
    [
        html.H3("Interface d'annotation", className='text-center my-3'),
        dcc.Graph(id="graph-styled-annotations", figure=fig),

        # Store the filename in hidden storage
        dcc.Store(id='filename_store', data=filename),

        dcc.Upload(
            id="import-image",
            children=html.Div(
                ['Glissez et déposez une image ici, ou ',
                 html.A('sélectionnez une image')],
                style={
                    'borderWidth': '0.5px', 'borderStyle': 'solid', 'backgroundColor':'rgba(66, 66, 66, 0.15)',
                    'padding': '20px', 'textAlign': 'center', 'width': '50%',
                    'margin': '5px auto', 'cursor': 'pointer',
                    'font-family': 'Roboto, sans-serif',
                }
            ),
            multiple=False
        ),

        dbc.Modal(
            [
                dbc.ModalHeader("Confirmation de l'importation"),
                dbc.ModalBody("Voulez-vous confirmer l'importation de ce fichier ?"),
                dbc.ModalFooter(
                    [
                        dbc.Button("Oui", id="confirmer_modal", color="success"),
                        dbc.Button("Non", id="fermer_modal", color="danger", className="ms-2"),
                    ]
                ),
            ],
            id="modal",
            is_open=False,
        ),
        dbc.Row(
            [
                dbc.Col(
                    dbc.Button(
                        "Valider l'annotation",
                        id="bouton_valider",
                        color='success',
                        n_clicks=0,
                    ),
                    width='auto'
                ),
                
                dbc.Col(
                    dbc.Button(
                        "Modifier l'annotation",
                        id="bouton_reset",
                        color='danger',
                        n_clicks=0,
                    ),
                    width='auto'
                ),
            ],
            justify='center',
            className='my-3',
        ),
        html.Pre(id="annotation_data", className='my-3'),
        dcc.Store(id='user_name_store', storage_type='local'), # Store the current user's name in the session
    ]
)

# Callback to handle the upload modal and image display
@callback(
    Output('modal', 'is_open'), # Open or close the modal
    Output('graph-styled-annotations', 'figure', allow_duplicate=True), # Update the displayed image
    Input('import-image', 'contents'),
    Input('fermer_modal', 'n_clicks'),
    Input('confirmer_modal', 'n_clicks'),
    State('modal', 'is_open'),
    State('import-image', 'filename'),
    State('graph-styled-annotations', 'figure'),
    prevent_initial_call=True
)
def activer_modal(contenu_img, cancel_clicks, confirm_clicks, is_open, filename, current_fig):
    # Open the modal when an image is uploaded
    if contenu_img is not None and is_open is False:
        return True, current_fig
    
    # If "No" is clicked, close the modal without doing anything
    if cancel_clicks:
        return False, current_fig
    
    # If "Yes" is clicked, save the image
    if confirm_clicks:
        save_img(contenu_img, filename)
        
        # Load the saved image to display
        img, next_filename = charger_image()  # Get the next image and its filename
        if img is not None:
            fig = px.imshow(img)
            fig.update_layout(
                dragmode="drawrect",
                newshape=dict(fillcolor="cyan", opacity=0.3, line=dict(color="black", width=2)),
            )
            # Update the filename in store
            return False, fig

        return False, None  # In case no next image is available
    
    # If no action has been taken, do not change anything
    return is_open, current_fig

# Callback to handle annotation submission
@callback(
    Output('annotation_data', 'children'),
    Output('graph-styled-annotations', 'figure'),
    Output('bouton_valider', 'disabled', allow_duplicate=True),
    Output('filename_store', 'data'),  # Add this output to update the filename store
    Input("bouton_valider", "n_clicks"),
    State('graph-styled-annotations', 'relayoutData'),
    State('user_name_store', 'data'),
    State('filename_store', 'data'), 
    prevent_initial_call=True
)
def afficher_annotation(n_clicks, relayoutData, user_name, filename):
    if n_clicks is None and user_name:
        return dash.no_update, dash.no_update, True, dash.no_update

    if relayoutData is not None and 'shapes' in relayoutData and relayoutData['shapes']:
        try:
            # Load existing annotations
            annotations_data = []
            if os.path.exists(annotations_file):
                with open(annotations_file, 'r') as f:
                    annotations_data = json.load(f)

            # Create a new annotation entry
            new_annotation = {
                'id': len(annotations_data) + 1,
                'image_name': filename,  # Ensure this is set correctly
                'annotateur': user_name,
                'date': datetime.now().strftime('%Y-%m-%d'),
                'reviewer': '',
                "review_date": '',
                'annotations': relayoutData['shapes']
            }

            # Append new annotation and save
            annotations_data.append(new_annotation)
            with open(annotations_file, 'w') as f:
                json.dump(annotations_data, f, indent=2)

            # Confirmation message
            message = f"L'annotation réalisée par {user_name} a bien été enregistrée."

            # Load the next image
            img, next_filename = charger_image()  # Get the next image and filename
            if img is not None:
                fig = px.imshow(img)
                fig.update_layout(
                    dragmode="drawrect",
                    newshape=dict(fillcolor="cyan", opacity=0.3, line=dict(color="black", width=2)),
                )
                
                # Update the filename in the store
                return html.Div(message, className='text-center', style={'font-family': 'Roboto, sans-serif'}), fig, True, next_filename

            else:
                return html.Div(message, className='text-center', style={'font-family': 'Roboto, sans-serif'}), None, True, dash.no_update

        except Exception as e:
            return html.Div("L'annotation a échoué, veuillez réessayer.", style={'font-family': 'Roboto, sans-serif'}), dash.no_update, True, dash.no_update

    return html.Div("Veuillez réaliser une annotation avant de valider", className='text-center', style={'font-family': 'Roboto, sans-serif'}), dash.no_update, False, dash.no_update


# Callback to enable/disable the validation button based on annotations
@callback(
    Output('bouton_valider', 'disabled'),
    Input('graph-styled-annotations', 'relayoutData'),
)
def activer_bouton(relayoutData):
    if relayoutData is not None and 'shapes' in relayoutData and relayoutData['shapes']:
        return False
    return True

```

`\\?\J:\BUT SD\S5\Projet_Dash\pages\login.py`:

```py
import dash
from dash import dcc, html, Input, Output, callback, State
import dash_bootstrap_components as dbc
import json
import os

dash.register_page(__name__, path='/') # '/' sert à faire la page d'accueil

# Liste des annotateurs déjà connus
data_users = './data/users.json'

def load_users():
    if os.path.exists(data_users):
        with open(data_users, 'r', encoding='utf-8') as file:
            return json.load(file)
    return []

# Fonction pour sauvegarder les utilisateurs
def save_users(users):
    with open(data_users, 'w', encoding='utf-8') as file:
        json.dump(users, file, indent=4)

users = load_users()

def generate_user_id():
    if users:
        return max(user['id'] for user in users) + 1
    return 1

layout = dbc.Container(
        [
            

            dbc.Row(
                dbc.Col(
                    html.H1("Bienvenue sur l'interface d'annotation du groupe M2VT", className="text-center mt-5")
                )
            ),
            dbc.Row(
                [
                    dbc.Col(
                        dbc.Card(
                            [
                                dbc.CardHeader("Identifiez-vous"),
                                dbc.CardBody(
                                    [
                                        html.H5("Sélectionnez un utilisateur ou ajoutez-en un nouveau", className="card-title"),
                                        dcc.Dropdown(id='user_dropdown', 
                                                     options=[{'label': user['name'], 'value': user['id']} for user in users],
                                                     placeholder="Sélectionnez votre nom",
                                                     className="mb-3"),
                                        dbc.Input(id='new_user', type='text', 
                                                  placeholder='Ou entrez un nouveau nom..',
                                                  className="mb-3"),
                                        dbc.Button('Se connecter', id='start_button', color='primary', 
                                                   n_clicks=0, className='d-grid gap-2 col-6 mx-auto'), # Centrage du bouton grâce à la grille CSS
                                        html.Div(id='user_message', className='mt-3'),
                                        html.Div(className="mt-3") # Ajout d'un peu d'espace en bas de la card
                                    ]
                                )
                            ],
                            className="shadow-lg p-3 mb-2 bg-white rounded" # Ombrage + Marge Basse + Bord rond blanc
                        ),
                        width=6, # Centrer au milieu de la page
                        className="offset-md-3"  # Centre la colonne dans la page
                    )
                ],
                className="mt-5"
            ),
            dbc.Row(
                dbc.Col(
                    html.Footer([
                        dcc.Markdown("""
                            **© 2024 Projet d'annotation - Dash**
                                     
                            Contributeurs du projet : Thibault DAGUIN, Vadim MARTIN, Maël CHAINE, Manon BONNAUD-DUBOIS
                            """)
                    ],
                        className="text-center mt-5"
                    )
                )
            ),
            dcc.Store(id='user_name_store', storage_type='local'),  # Pour stocker le nom d'utilisateur en cours sur la session
        ],
        fluid=False
    )

@callback(
    Output('user_dropdown', 'options'),
    Input('user_dropdown', 'value'),
)

def update_user_dropdown(selected_user):
    # Mettre à jour la liste des utilisateurs
    users = load_users()
    return [{'label': user['name'], 'value': user['id']} for user in users]

@callback(
    Output('user_message', 'children'), # Message de connexion
    Output('user_name_store', 'data'), # Stocker le nom d'utilisateur
    Output('url', 'href'), # Redirection vers la page d'accueil
    Input('start_button', 'n_clicks'), # Clic sur le bouton de connexion
    State('new_user', 'value'), # Valeur du nouvel utilisateur
    State('user_dropdown', 'value') # Valeur de l'utilisateur sélectionné
)

def gestion_connexion(n_clicks, new_user, selected_user):
    # Gère la connexion d'un utilisateur ou d'un nouvel utilisateur
    if n_clicks > 0:
        if new_user:
            return add_new_user(new_user)
        
        if selected_user:
            return select_existing_user(selected_user)
    
    return not_connected(), None, dash.no_update

def add_new_user(new_user):
    # Ajoute un nouvel utilisateur
    users = load_users()

    # Vérifier si l'utilisateur existe déjà
    if any(user['name'] == new_user for user in users):
        return "L'utilisateur existe déjà.", None, dash.no_update
    
    # Ajouter le nouvel utilisateur
    new_user_id = generate_user_id()
    new_user_data = {
        'id': new_user_id,
        'name': new_user
        }
    users.append(new_user_data)
    save_users(users)

    return f"Nouvel utilisateur {new_user_data['name']} ajouté.", new_user_data['name'], '/accueil'

def select_existing_user(selected_user):
    # Retourne les infos d'un utilisateur existant
    users = load_users()
    user_name = next((user['name'] for user in users if user['id'] == selected_user), None)
    return f"Vous êtes loggé en tant que {user_name}.", user_name, '/accueil'

def not_connected():
    # Retourne un message si l'utilisateur n'est pas connecté
    return html.Div([
        html.I(className="fas fa-exclamation-circle text-danger me-2"),  # Icône d'exclamation rouge
        "Vous n'êtes pas loggé."
    ], className='d-flex align-items-center')

def afficher_message_loggé():
    # Affiche un message si l'utilisateur est connecté
    return html.Div(id='user_status', className='text-right mt-2')

```

`\\?\J:\BUT SD\S5\Projet_Dash\pages\stats.py`:

```py
import dash
from dash import html

dash.register_page(__name__)

layout = html.Div([
    html.H1("C'est la page des stats"),
    html.Div("C'est la page des stats"),
])
```

`\\?\J:\BUT SD\S5\Projet_Dash\pages\verify.py`:

```py
import dash
from dash import dcc, html, Input, Output, State
import dash_bootstrap_components as dbc
import plotly.express as px
from skimage import io
import os
import json
from urllib.parse import urlparse, parse_qs
from datetime import datetime

dash.register_page(__name__, path_template="/verify")

# File paths
dossier_img = './data/cars/'
annotations_file = './data/annotations.json'

# Function to load annotation by ID
def get_annotation_by_id(annotation_id):
    if os.path.exists(annotations_file):
        with open(annotations_file, 'r') as f:
            annotations = json.load(f)
            for annotation in annotations:
                if str(annotation['id']) == str(annotation_id):  # Ensure ID is compared as string
                    return annotation
    return None

# Function to load image by name
def load_image(image_name):
    img_path = os.path.join(dossier_img, image_name)
    if os.path.exists(img_path):
        return io.imread(img_path)
    else:
        print(f"Image {image_name} not found at path {img_path}")
        return None

# Layout for the verify page
layout = html.Div([
    html.H3("Vérifier l'Annotation"),
    dcc.Graph(id='annotation-graph'),
    dbc.Button("Valider", id="valider-button", color="success", n_clicks=0),
    html.Div(id="action-message") 
])

# Callback to display image with annotations
@dash.callback(
    Output('annotation-graph', 'figure'),
    Input('url', 'href')
)
def display_image_with_annotations(href):
    if href:
        # Parse the URL to extract the annotation ID
        parsed_url = urlparse(href)
        params = parse_qs(parsed_url.query)
        annotation_id = params.get('id', [None])[0]

        if annotation_id:
            # Get annotation data by ID
            annotation = get_annotation_by_id(annotation_id)
            if annotation:
                # Load the corresponding image
                image = load_image(annotation['image_name'])
                if image is not None:
                    fig = px.imshow(image)

                    # Iterate through each annotation shape and add it to the figure
                    for ann in annotation['annotations']:
                        fig.add_shape(
                            type=ann['type'],
                            x0=ann['x0'],
                            y0=ann['y0'],
                            x1=ann['x1'],
                            y1=ann['y1'],
                            line=dict(
                                color=ann['line']['color'],
                                width=ann['line']['width'],
                                dash=ann['line']['dash']
                            ),
                            fillcolor=ann['fillcolor'],
                            opacity=ann['opacity']
                        )

                    return fig
    return {}

# Callback to handle "Valider" button click and update the reviewer and review_date
@dash.callback(
    Output('action-message', 'children'),
    Input('valider-button', 'n_clicks'),
    State('url', 'href'),
    State('user_name_store', 'data'),
    prevent_initial_call=True
)
def handle_valider(n_clicks, href, user_name):
    if n_clicks > 0 and user_name:
        # Parse the URL to extract the annotation ID
        parsed_url = urlparse(href)
        params = parse_qs(parsed_url.query)
        annotation_id = params.get('id', [None])[0]

        if annotation_id:
            # Load the annotation and update the reviewer and review_date
            if os.path.exists(annotations_file):
                with open(annotations_file, 'r') as f:
                    annotations = json.load(f)
                
                for annotation in annotations:
                    if str(annotation['id']) == str(annotation_id):  # Ensure ID comparison is correct
                        # Update the reviewer field
                        annotation['reviewer'] = user_name
                        # Add the review date in YYYY-MM-DD format
                        annotation['review_date'] = datetime.now().strftime('%Y-%m-%d')
                        break

                # Save the updated annotations
                with open(annotations_file, 'w') as f:
                    json.dump(annotations, f, indent=2)

                return f"L'annotation a bien été validée par {user_name}."

    return "Une erreur s'est produite lors de la validation."

```

`\\?\J:\BUT SD\S5\Projet_Dash\requirements.txt`:

```txt
dash==2.11.0
dash-bootstrap-components==1.5.2
plotly==5.11.0
scikit-image==0.20.0
Pillow==9.5.0
```